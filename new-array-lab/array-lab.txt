           CS 40 Lab: Unboxed and 2D Arrays


+--------------------------------------------------------+
|Keeper of the record:   Vedant Modi (vmodi01)                                |
|--------------------------------------------------------|
| Other group member(s):                                 |
|                                                        |
|     Josh Field (jfield02)                                                   |
|                                                        |
+--------------------------------------------------------+


PART 1: BOXED AND UNBOXED ARRAYS
--------------------------------

You are about to design the interface and implementation for a
collection data type, i.e., an ADT like Hanson's, and you are
considering the tradeoffs between using a boxed or an unboxed
interface for values that users store in your collection.

1A: Briefly define the terms "boxed" and "unboxed" as used for these
    interfaces (i.e., help us be sure you know which is which!):


Boxed arrays contain pointers to the data representation (the data stored in 
the array points to the actionable data).

Unboxed arrays contain the elements of data itself, meaning that the actual 
data, instead of a level of indirection that is required when using a pointer.


1B: List two (or more) advantages of the boxed representation.


1. Boxed representation allows for polymorphism, meaning the same 
implementation can work universally for anything that can be pointed to.
2. Boxed representation allows for better abstraction, as the pointers are 
void, so can therefore point to any address in memory.


1C: List two (or more) advantages of an unboxed representation.


1. Unboxed representation is quicker (no dereferencing), which allows 
for a better-running program.
2. Unboxed representation requires less storage as each element only requires 
storage for the actionable data and not an additional pointer.


1D: Look at the interface to UArray (a link to an interface
    summary is at the start of the lab instructions). Discuss the 
    methods that show the use of the unboxed style. Why, for example, 
    does UArray_new take both a number of elements and an element size? 


The UArray_new function takes both the number of elements and element size to 
properly allocate the right amount of space. Since the UArray can contain 
differing element types, the size of each element is dynamic and therefore 
must be included in the initialization.

The size of the element is required because the array has to allocate length 
of elements * size of elements contiguously in memory. The size here is 
required so one element is not able to overlap onto another in memory, 
and therefore cause data loss. As in, there will be size bytes allocated for 
each element, and then size bytes after the start of the first allocation, 
there will be another allocation of size bytes, and so on, and so forth!



PART 2: 2D Arrays from 1D Arrays
--------------------------------

2A. One way to construct a 2D array is to use multiple 1D
    arrays. Describe briefly how you would do this. For example, if
    the user asked you to create a 5x7 array of values, how many
    one-dimensional arrays would you create? If the user asked to
    store a value in cell [3,6] where would it go?

    One would create 5 arrays of length 7, each to represent a row, 
    and place them inside a length 5 array representing the rows. To access
    the cell [3,6], we would access the 4th element (zero-indexed) of the 
    length 5 array, and place the data in the 7th element of that array
    (zero-indexed).

    
2B. Another approach is to use a single one-dimensional array and to
    put all the elements of the 2D array into that. Again, assuming
    that you are to create a 7x5 2D array, give a mathematical formula
    for the index in the 2D array where a value [x,y] would go in the
    1D array.

    There would be one array of size col * row in which to access 
    the element [x,y] , one would calculate (col * y) + x  and access that 
    element of the 1d array.


2C. (optional) is there another mapping that would work as well?


PART 3: Designing the UArray2 Interface
---------------------------------------

3A. Describe three (or more) things you learned about the design and semantics
    of the UArray2 interface from reading useuarray2.c and from running
    correct_useuarray2.


1. The use of ternary operators for printing can be quite useful for debugging
2. The row/col major relies on a function pointer which makes modularity so
simple, rather than just having two different functions for printing each.
3. The indirect return in map col/row major was very smooth and certainly 
helps with the functionality of the function.






